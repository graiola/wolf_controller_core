/**
WoLF: WoLF: Whole-body Locomotion Framework for quadruped robots (c) by Gennaro Raiola

WoLF is licensed under a license Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.

You should have received a copy of the license along with this
work. If not, see <http://creativecommons.org/licenses/by-nc-nd/4.0/>.
**/

#ifndef WPG_FOOTHOLDS_PLANNER_H
#define WPG_FOOTHOLDS_PLANNER_H

#include <ros/ros.h>
#include <Eigen/Core>
#include <Eigen/Dense>
#include <atomic>
#include <wolf_controller_core/wpg/gait_generator.h>
#include <wolf_controller_core/state_machine.h>
// WoLF utils
#include <wolf_controller_utils/tools.h>
// WoLF wbid
#include <wolf_wbid/quadruped_robot.h>

namespace wolf_controller
{

class FootholdsPlanner;

class PushRecovery
{

public:

  const std::string CLASS_NAME = "PushRecovery";

  /**
   * @brief Shared pointer to PushRecovery
   */
  typedef std::shared_ptr<PushRecovery> Ptr;


  /**
   * @brief Calculate the capture point and use that to add deltas to the footholds.
   * A push is detected when the capture point is outside the support polygon.
   */
  PushRecovery(FootholdsPlanner* const footholds_planner_ptr);

  /**
   * @brief update updates the push recovery detector and computes the delta to apply at the footholds (x,y) in order to stop
   * the robot, return true if a push is detected.
   * @param period control sample time
   */
  bool update(const double& period);

  /**
   * @brief getDelta get the delta [x,y] generated by the push recovery for a specific foot
   * @param foot_name
   */
  const Eigen::Vector2d& getDelta(const std::string& foot_name);

  /**
   * @brief getSupportPolygonEdges get the support polygon edges
   */
  const std::vector<Eigen::Vector2d>& getSupportPolygonEdges();

  /**
   * @brief getCapturePoint get the capture point calculated by the push recovery
   */
  const Eigen::Vector2d& getCapturePoint();

  /**
   * @brief getComPosition get the CoM position XY integrated by the push recovery
   */
  const Eigen::Vector2d& getComPositionXY();

  /**
   * @brief setMaxDelta set the max delta step that can be generated by the push recovery
   * @param max [m]
   */
  void setMaxDelta(const double &max);

  /**
   * @brief activate the computation of the deltas for the push recovery
   */
  void activateComputeDeltas();

  /**
   * @brief de-activate the computation of the deltas for the push recovery
   */
  void deactivateComputeDeltas();

  /**
   * @brief set a scale value between 0 and 1 for the support polygon
   */
  void setScaleValue(double scale);

  /**
   * @brief get the scale value for the support polygon
   */
  double getScaleValue();

  /**
   * @brief get the ordered foot names associated with the polygon vertex
   */
  const std::vector<std::string>& getOrderedFootNames();

private:

  FootholdsPlanner* footholds_planner_ptr_;
  std::atomic<bool> compute_deltas_;
  std::atomic<double> scale_;
  std::map<std::string,Eigen::Vector2d> deltas_;
  Eigen::Vector2d com_pos_xy_;
  Eigen::Vector3d com_pos_;
  Eigen::Vector2d capture_point_;
  Eigen::Vector3d com_vel_;
  XBot::Utils::SecondOrderFilter<Eigen::Vector3d> com_vel_filt_;
  double max_delta_;
  bool push_detected_;
  std::vector<float> vertx_;
  std::vector<float> verty_;
  std::vector<std::string> ordered_foot_names_;
  std::map<std::string,Eigen::Vector3d> feet_pos_;
  std::vector<Eigen::Vector2d> support_polygon_edges_;

  Eigen::Vector3d tmp_vector3d_;

  wolf_controller_utils::Trigger gait_cycle_ended_;
};

/**
 * @brief This class plans the footholds for the feet
 */
class FootholdsPlanner
{

public:

    const std::string CLASS_NAME = "FootholdsPlanner";

    /**
     * @brief Shared pointer to FootholdsPlanner
     */
    typedef std::shared_ptr<FootholdsPlanner> Ptr;

    /**
     * @brief Shared pointer to const FootholdsPlanner
     */
    typedef std::shared_ptr<const FootholdsPlanner> ConstPtr;

    enum cmd_t {HOLD=0,LINEAR,ANGULAR,LINEAR_AND_ANGULAR,BASE_ONLY,RESET_BASE};

    /**
     * @brief FootholdsPlanner constructor
     * @param gait generator
     * @param robot model
     * @param maximum step length
     * @param maximum step height
     */
    FootholdsPlanner(StateMachine::Ptr state_machine, GaitGenerator::Ptr gait_generator, wolf_wbid::QuadrupedRobot::Ptr robot_model, double step_length_max = 0.3, double step_height_max = 0.3);

    /**
     * @brief update triggers an update step of the footholds planner to compute the next foot holds given a base twist command.
     * This function performs an update with an open loop base orientation.
     * @param period
     * @param base_position current base position xyz
     */
    void update(const double& period,const Eigen::Vector3d& base_position);

    /**
     * @brief update triggers an update step of the footholds planner to compute the next foot holds given a base twist command.
     * This function performs an update with an open loop base position and orientation.
     * @param period
     */
    void update(const double& period);

    /**
     * @brief update triggers an update step of the footholds planner to compute the next foot holds given a base twist command.
     * This function performs an update with an closed loop base position and orientation.
     * @param period
     * @param base_position current base position xyz
     * @param base_orientation current base orientation roll pitch yaw
     */
    void update(const double& period, const Eigen::Vector3d& base_position, const Eigen::Vector3d& base_orientation);

    /**
     * @brief initialize the feet position in the gait generator given the current robot configuration. The positions
     * are expressed wrt world
     */
    void initializeFeetPosition();

    /**
     * @brief initialize a specific foot position in the gait generator given the current robot configuration. The position
     * is expressed wrt world
     * @param foot_name
     */
    void initializeFootPosition(const std::string& foot_name);

    /**
     * @brief reset the foot holds planner
     */
    void reset();

    /**
     * @brief Set functions
     */
    void setCmd(const unsigned int cmd);
    void setBasePosition(const Eigen::Vector3d& position);
    void setBaseOrientation(const Eigen::Vector3d& orientation);
    void setDefaultBaseOrientation(const Eigen::Vector3d& orientation);
    void setDefaultBasePosition(const Eigen::Vector3d& position);
    void setBaseVelocityScaleX(const double& scale);
    void setBaseVelocityScaleY(const double& scale);
    void setBaseVelocityScaleZ(const double& scale);
    void setBaseVelocityScaleRoll(const double& scale);
    void setBaseVelocityScalePitch(const double& scale);
    void setBaseVelocityScaleYaw(const double& scale);
    void setBaseLinearVelocityCmd(const double& linear);
    void setBaseAngularVelocityCmd(const double& angular);
    void setBaseLinearVelocityCmd(const double& x, const double& y, const double& z, bool verbose = false);
    void setBaseAngularVelocityCmd(const double& roll, const double& pitch, const double& yaw, bool verbose = false);
    void setBaseLinearVelocityCmdX(const double& v);
    void setBaseLinearVelocityCmdY(const double& v);
    void setBaseLinearVelocityCmdZ(const double& v);
    void setBaseAngularVelocityCmdRoll(const double& v);
    void setBaseAngularVelocityCmdPitch(const double& v);
    void setBaseAngularVelocityCmdYaw(const double& v);
    void setStepHeight(const double& height);
    void setMaxStepHeight(const double& max);
    void setMaxStepLength(const double& max);
    void setMaxBaseHeight(const double& max);
    void setMaxBaseRoll(const double& max);
    void setMaxBasePitch(const double& max);
    void setMinBaseRoll(const double& min);
    void setMinBasePitch(const double& min);
    void setTerrainTransform(const Eigen::Affine3d& world_T_terrain);
    void setPushRecoverySensibility(const double& v);

    /**
     * @brief Get functions
     */
    unsigned int getCmd();
    const Eigen::Vector3d& getBasePositionReference() const;
    const Eigen::Vector3d& getBaseLinearVelocityReference() const;
    const Eigen::Vector3d& getBaseAngularVelocityReference() const;
    const Eigen::Vector3d& getBaseLinearVelocityReferenceHF() const;
    const Eigen::Vector3d& getBaseAngularVelocityReferenceHF() const;
    const Eigen::Matrix3d& getBaseRotationReference() const;
    const double& getStepLength(const std::string& foot_name);
    const double& getStepHeading(const std::string& foot_name);
    const double& getStepHeight(const std::string& foot_name);
    const double& getStepHeadingRate(const std::string& foot_name);
    const double& getBaseHeight() const;
    double getBaseLinearVelocityCmdX() const;
    double getBaseLinearVelocityCmdY() const;
    double getBaseLinearVelocityCmdZ() const;
    double getBaseAngularVelocityCmdRoll() const;
    double getBaseAngularVelocityCmdPitch() const;
    double getBaseAngularVelocityCmdYaw() const;
    double getStepHeight() const ;
    double getStepLength() const ;
    Gait::gait_t getGaitType() const;
    Eigen::Vector3d& getCurrentFoothold(const std::string& foot_name) ;
    Eigen::Vector3d& getCurrentFootholdHF(const std::string& foot_name) ;
    Eigen::Vector3d& getVirtualFoothold(const std::string& foot_name) ;
    Eigen::Vector3d& getDesiredFoothold(const std::string& foot_name) ;
    const std::vector<std::string>& getFootNames() const;
    double getSwingFrequency();
    double getCycleTime();
    double getVelocityFactor();
    double getPushRecoverySensibility();

    /**
     * @brief Increase step height
     */
    void increaseStepHeight();

    /**
     * @brief Decrease step height
     */
    void decreaseStepHeight();

    /**
     * @brief Increase the swing frequency
     */
    void increaseSwingFrequency();

    /**
     * @brief Decrease the swing frequency
     */
    void decreaseSwingFrequency();

    /**
     * @brief activate/deactivate the push recovery
     */
    void togglePushRecovery();

    /**
     * @brief check if the push recovery is active
     */
    bool isPushRecoveryActive() const;

    /**
     * @brief start the push recovery
     */
    void startPushRecovery(bool start);

    /**
     * @brief check if any of the robot's feet is in touch down i.e. it just hit ground
     */
    bool isAnyFootInTouchDown();

    /**
     * @brief check if all the robot's feet are on the ground
     */
    bool areAllFeetInStance();

    /**
     * @brief check if any of the robot's feet is in the air
     */
    bool isAnyFootInSwing();

    /**
     * @brief true if a complete gait cycle is ended
     */
    bool isGaitCycleEnded();

    /**
         * @brief Get Push Recovery
         */
    PushRecovery* getPushRecovery() const;

private:

    void setInitialOffsets();

    void calculateFootSteps();

    void resetFeetStep();

    void resetBaseAngularVelocity();

    void resetBaseLinearVelocity();

    void resetBaseVelocities();

    void resetBasePosition();

    void resetBaseOrientation();

    void resetVelocyScales();

    void calculateBasePosition(const double& period, const Eigen::Vector3d& base_position);

    void calculateBaseOrientation(const double& period, const Eigen::Vector3d& base_orientation);

    /**
     * @brief these attributes are modified by the external interfaces (e.g joypad and dynamic_reconfigure)
     */
    std::atomic<unsigned int> cmd_;
    std::atomic<double>  base_linear_velocity_scale_x_;
    std::atomic<double>  base_linear_velocity_scale_y_;
    std::atomic<double>  base_linear_velocity_scale_z_;
    std::atomic<double>  base_angular_velocity_scale_roll_;
    std::atomic<double>  base_angular_velocity_scale_pitch_;
    std::atomic<double>  base_angular_velocity_scale_yaw_;
    std::atomic<double>  base_linear_velocity_cmd_x_;
    std::atomic<double>  base_linear_velocity_cmd_y_;
    std::atomic<double>  base_linear_velocity_cmd_z_;
    std::atomic<double>  base_angular_velocity_cmd_roll_;
    std::atomic<double>  base_angular_velocity_cmd_pitch_;
    std::atomic<double>  base_angular_velocity_cmd_yaw_;
    std::atomic<double>  step_height_max_;
    std::atomic<double>  step_length_max_;
    std::atomic<double>  base_height_max_;
    std::atomic<double>  base_roll_max_;
    std::atomic<double>  base_pitch_max_;
    std::atomic<double>  base_roll_min_;
    std::atomic<double>  base_pitch_min_;
    std::atomic<double>  step_height_;
    std::atomic<bool>    push_detected_;
    std::atomic<bool>    push_recovery_active_;

    /** @brief base linear velocity w.r.t horizontal frame
     * (i.e. a frame that has the same position as the base link but oriented as the world except for the yaw which is the same as the base)
    */
    Eigen::Vector3d hf_base_linear_velocity_;
    /** @brief base angular velocity w.r.t horizontal frame
     * (i.e. a frame that has the same position as the base link but oriented as the world except for the yaw which is the same as the base)
    */
    Eigen::Vector3d hf_base_angular_velocity_;

    Eigen::Vector3d hf_base_linear_velocity_filt_;
    Eigen::Vector3d hf_base_angular_velocity_filt_;

    Eigen::Vector3d hf_base_linear_velocity_ref_;
    Eigen::Vector3d hf_base_angular_velocity_ref_;

    Eigen::Vector3d base_position_;
    Eigen::Vector3d base_orientation_;
    Eigen::Vector3d default_base_orientation_;
    Eigen::Vector3d default_base_position_;

    Eigen::Vector3d base_position_filt_;
    Eigen::Vector3d base_orientation_filt_;

    Eigen::Vector3d hf_delta_hip_;
    Eigen::Vector3d hf_delta_heading_;
    Eigen::Vector3d hf_delta_foot_;
    Eigen::Vector3d hf_X_current_foothold_;
    Eigen::Vector3d world_delta_hip_;
    Eigen::Vector3d world_delta_foot_;

    Eigen::Matrix3d world_R_hf_;
    Eigen::Matrix3d hf_R_base_;

    Eigen::Affine3d world_T_terrain_;
    Eigen::Affine3d world_T_terrain_init_;

    bool offsets_applied_;
    bool terrain_transform_init_;

    typedef std::map<std::string,double> map_t;
    map_t steps_length_;
    map_t steps_heading_;
    map_t steps_height_;
    map_t steps_heading_rate_;
    Eigen::Matrix3d base_rotation_reference_;
    Eigen::Vector3d base_position_reference_;
    Eigen::Vector3d base_linear_velocity_reference_;
    Eigen::Vector3d base_angular_velocity_reference_;

    StateMachine::Ptr state_machine_;
    GaitGenerator::Ptr gait_generator_;
    wolf_wbid::QuadrupedRobot::Ptr robot_model_;

    Eigen::Affine3d base_T_foot_;
    std::vector<Eigen::Vector3d> hf_X_initial_footholds_;
    std::vector<Eigen::Vector3d> hf_X_initial_hips_;

    std::map<std::string,Eigen::Vector3d> desired_foothold_;
    std::map<std::string,Eigen::Vector3d> virtual_foothold_;
    std::map<std::string,Eigen::Vector3d> current_foothold_;
    std::map<std::string,Eigen::Vector3d> current_foothold_hf_;
    std::map<std::string,Eigen::Vector2d> capture_point_delta_;

    double step_length_;

    friend class PushRecovery;
    PushRecovery::Ptr push_recovery_;

    Eigen::Affine3d tmp_affine3d_;
    Eigen::Affine3d tmp_affine3d_1_;
    Eigen::Affine3d tmp_matrix3d_;
};

} // namespace

#endif
